import asyncio
from socket import socket
from typing import Callable, Dict, Tuple

from .handshake import perform_handshake


def decode_websocket_message(frame: bytes):
    """
    function generated by ChatGPT to decode a websocket message into plain text
    """
    byte_array = bytearray(frame)

    # Check the opcode
    opcode = byte_array[0] & 0x0F

    if opcode == 0x1:
        # Text frame
        message_type = "Text"
    elif opcode == 0x8:
        # Close frame
        message_type = "Close"
    else:
        return f"Unsupported opcode: {opcode}"

    # Get the payload length
    length = byte_array[1] & 0x7F
    mask_start = 2

    if length == 126:
        length = int.from_bytes(byte_array[2:4], "big")
        mask_start = 4
    elif length == 127:
        length = int.from_bytes(byte_array[2:10], "big")
        mask_start = 10

    # Extract mask key
    mask = byte_array[mask_start : mask_start + 4]

    # Extract payload
    payload = byte_array[mask_start + 4 :]

    # Unmask the payload
    unmasked = bytearray(length)
    for i in range(length):
        unmasked[i] = payload[i] ^ mask[i % 4]

    if message_type == "Text":
        # Decode the payload as UTF-8 for text frames
        return f"Text message: {unmasked.decode('utf-8')}"
    elif message_type == "Close":
        if len(unmasked) >= 2:
            # Extract close status code
            status_code = int.from_bytes(unmasked[:2], "big")
            reason = unmasked[2:].decode("utf-8") if len(unmasked) > 2 else ""
            return f"Close message: Status Code: {status_code}, Reason: {reason}"
        else:
            return "Close message without status code"


class SocketAlreadyRegisteredException:
    pass


class SocketManager:
    def __init__(self):
        self.socket_dict: Dict[Tuple[str, int], socket] = {}

    def __get_socket(self, client_addr: Tuple[str, int]) -> socket | None:
        if client_addr in self.socket_dict:
            return self.socket_dict[client_addr]
        return None

    def register_socket(self, client_addr: Tuple[str, int], socket: socket):
        if client_addr in self.socket_dict:
            raise ""  # TODO: add an exception
        self.socket_dict[client_addr] = socket

    def unregister_socket(self, client_addr: Tuple[str, int]):
        self.socket_dict.pop(client_addr, None)

    async def read_from_socket(
        self,
        client_addr: Tuple[str, int],
        callback_fn: Callable[[Tuple[str, int], str], None],
    ):
        loop = asyncio.get_event_loop()
        socket = self.__get_socket(client_addr)
        if socket is None:
            raise ""  # TODO: add an exception
        try:
            while True:
                data = await loop.sock_recv(socket, 1024)  # Read from socket
                if not data:
                    break
                decoded_data = decode_websocket_message(data)
                if decoded_data.startswith("Close"):
                    break
                if decoded_data.startswith(
                    "Unsupported opcode"
                ) and "Upgrade: websocket" in data.decode("utf-8"):
                    if not perform_handshake(socket, client_addr, data.decode("utf-8")):
                        print(f"Failed WebSocket handshake with {client_addr}")
                        break
                    else:
                        continue
                elif decoded_data.startswith("Unsupported opcode"):
                    socket.send(b"HTTP/1.1 400 Bad Request\r\n\r\n")
                    break
                callback_fn(client_addr, decoded_data)
        except Exception as e:
            print(f"Exception: {e}")
        finally:
            socket.close()
            self.unregister_socket(client_addr)
            print(f"Connection with {client_addr} closed.")

    def write_to_socket(self, client_addr: Tuple[str, int], data: bytes):
        socket = self.__get_socket(client_addr)
        if socket is None:
            raise ""  # TODO: add an exception
        socket.send(data)
